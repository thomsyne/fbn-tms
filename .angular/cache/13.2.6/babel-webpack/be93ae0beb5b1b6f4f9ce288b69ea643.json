{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, Directive, Self, SkipSelf, Input, HostBinding, NgModule, isDevMode } from '@angular/core';\nimport { Subject, pipe, BehaviorSubject, Subscription, NEVER, timer, of, merge } from 'rxjs';\nimport { filter, map, shareReplay, distinctUntilChanged, tap, switchMap, first, auditTime } from 'rxjs/operators';\nimport * as i1 from '@angular/forms';\nimport { FormGroup, FormArray, FormControl } from '@angular/forms';\n/**\r\n * Provides a way to add to available options for when to display an error for\r\n * an invalid control. Options that come by default are\r\n * `'touched'`, `'dirty'`, `'touchedAndDirty'`, `'formIsSubmitted'`.\r\n */\n\nconst CUSTOM_ERROR_STATE_MATCHERS = new InjectionToken('CUSTOM_ERROR_STATE_MATCHERS');\n\nclass ShowOnTouchedErrorStateMatcher {\n  isErrorState(control, form) {\n    return !!(control && control.invalid && (control.touched || form && form.submitted));\n  }\n\n}\n\nShowOnTouchedErrorStateMatcher.ɵfac = function ShowOnTouchedErrorStateMatcher_Factory(t) {\n  return new (t || ShowOnTouchedErrorStateMatcher)();\n};\n\nShowOnTouchedErrorStateMatcher.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ShowOnTouchedErrorStateMatcher,\n  factory: ShowOnTouchedErrorStateMatcher.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ShowOnTouchedErrorStateMatcher, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass ShowOnDirtyErrorStateMatcher {\n  isErrorState(control, form) {\n    return !!(control && control.invalid && (control.dirty || form && form.submitted));\n  }\n\n}\n\nShowOnDirtyErrorStateMatcher.ɵfac = function ShowOnDirtyErrorStateMatcher_Factory(t) {\n  return new (t || ShowOnDirtyErrorStateMatcher)();\n};\n\nShowOnDirtyErrorStateMatcher.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ShowOnDirtyErrorStateMatcher,\n  factory: ShowOnDirtyErrorStateMatcher.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ShowOnDirtyErrorStateMatcher, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass ShowOnTouchedAndDirtyErrorStateMatcher {\n  isErrorState(control, form) {\n    return !!(control && control.invalid && (control.dirty && control.touched || form && form.submitted));\n  }\n\n}\n\nShowOnTouchedAndDirtyErrorStateMatcher.ɵfac = function ShowOnTouchedAndDirtyErrorStateMatcher_Factory(t) {\n  return new (t || ShowOnTouchedAndDirtyErrorStateMatcher)();\n};\n\nShowOnTouchedAndDirtyErrorStateMatcher.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ShowOnTouchedAndDirtyErrorStateMatcher,\n  factory: ShowOnTouchedAndDirtyErrorStateMatcher.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ShowOnTouchedAndDirtyErrorStateMatcher, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass ShowOnSubmittedErrorStateMatcher {\n  isErrorState(control, form) {\n    return !!(control && control.invalid && form && form.submitted);\n  }\n\n}\n\nShowOnSubmittedErrorStateMatcher.ɵfac = function ShowOnSubmittedErrorStateMatcher_Factory(t) {\n  return new (t || ShowOnSubmittedErrorStateMatcher)();\n};\n\nShowOnSubmittedErrorStateMatcher.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ShowOnSubmittedErrorStateMatcher,\n  factory: ShowOnSubmittedErrorStateMatcher.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ShowOnSubmittedErrorStateMatcher, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass ErrorStateMatchers {\n  constructor(showOnTouchedErrorStateMatcher, showOnDirtyErrorStateMatcher, showOnTouchedAndDirtyErrorStateMatcher, showOnSubmittedErrorStateMatcher, customErrorStateMatchers) {\n    this.matchers = {};\n    this.matchers['touched'] = showOnTouchedErrorStateMatcher;\n    this.matchers['dirty'] = showOnDirtyErrorStateMatcher;\n    this.matchers['touchedAndDirty'] = showOnTouchedAndDirtyErrorStateMatcher;\n    this.matchers['formIsSubmitted'] = showOnSubmittedErrorStateMatcher;\n\n    if (customErrorStateMatchers) {\n      this.matchers = Object.assign(Object.assign({}, this.matchers), customErrorStateMatchers);\n    }\n  }\n\n  get(showWhen) {\n    return this.matchers[showWhen];\n  }\n\n  validKeys() {\n    return Object.keys(this.matchers);\n  }\n\n}\n\nErrorStateMatchers.ɵfac = function ErrorStateMatchers_Factory(t) {\n  return new (t || ErrorStateMatchers)(i0.ɵɵinject(ShowOnTouchedErrorStateMatcher), i0.ɵɵinject(ShowOnDirtyErrorStateMatcher), i0.ɵɵinject(ShowOnTouchedAndDirtyErrorStateMatcher), i0.ɵɵinject(ShowOnSubmittedErrorStateMatcher), i0.ɵɵinject(CUSTOM_ERROR_STATE_MATCHERS, 8));\n};\n\nErrorStateMatchers.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ErrorStateMatchers,\n  factory: ErrorStateMatchers.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ErrorStateMatchers, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: ShowOnTouchedErrorStateMatcher\n    }, {\n      type: ShowOnDirtyErrorStateMatcher\n    }, {\n      type: ShowOnTouchedAndDirtyErrorStateMatcher\n    }, {\n      type: ShowOnSubmittedErrorStateMatcher\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [CUSTOM_ERROR_STATE_MATCHERS]\n      }]\n    }];\n  }, null);\n})();\n/**\r\n * Extract a touched changed observable from an abstract control\r\n * @param control AbstractControl like object with markAsTouched method\r\n *\r\n * @usage\r\n * ```\r\n * const formControl = new FormControl();\r\n * const touchedChanged$ = extractTouchedChanges(formControl);\r\n * ```\r\n */\n\n\nconst extractTouchedChanges = control => {\n  const prevMarkAsTouched = control.markAsTouched;\n  const prevMarkAsUntouched = control.markAsUntouched;\n  const touchedChanges$ = new Subject();\n\n  function nextMarkAsTouched(...args) {\n    touchedChanges$.next(true);\n    prevMarkAsTouched.bind(control)(...args);\n  }\n\n  function nextMarkAsUntouched(...args) {\n    touchedChanges$.next(false);\n    prevMarkAsUntouched.bind(control)(...args);\n  }\n\n  control.markAsTouched = nextMarkAsTouched;\n  control.markAsUntouched = nextMarkAsUntouched;\n  return touchedChanges$.asObservable();\n};\n/**\r\n * Marks the provided control as well as all of its children as dirty\r\n * @param options to be passed into control.markAsDirty() call\r\n */\n\n\nfunction markDescendantsAsDirty(control, options) {\n  control.markAsDirty(options);\n\n  if (control instanceof FormGroup || control instanceof FormArray) {\n    const controls = Object.keys(control.controls).map(controlName => control.get(controlName));\n    controls.forEach(c => {\n      c.markAsDirty(options);\n\n      if (c.controls) {\n        markDescendantsAsDirty(c, options);\n      }\n    });\n  }\n}\n\nfunction filterOutNullish() {\n  return pipe(filter(x => x != null));\n}\n\nclass NgxError extends Error {\n  constructor(message) {\n    super(`NgxError: ${message}`);\n  }\n\n}\n\nclass NoParentNgxErrorsError extends NgxError {\n  constructor() {\n    super('Directive ngxError requires a parent directive ngxErrors');\n  }\n\n}\n\nclass ValueMustBeStringError extends NgxError {\n  constructor() {\n    super('Directive ngxError requires a string value');\n  }\n\n}\n\nclass NoControlError extends NgxError {\n  constructor() {\n    super('Directive ngxErrors requires either control name or control instance');\n  }\n\n}\n\nclass ControlInstanceError extends NgxError {\n  constructor() {\n    super('Control must be either a FormGroup, FormControl or FormArray');\n  }\n\n}\n\nclass ControlNotFoundError extends NgxError {\n  constructor(name) {\n    super(`Control \"${name}\" could not be found`);\n  }\n\n}\n\nclass ParentFormGroupNotFoundError extends NgxError {\n  constructor(name) {\n    super(`Can't search for control \"${name}\" because parent FormGroup is not found`);\n  }\n\n}\n\nclass InvalidShowWhenError extends NgxError {\n  constructor(showWhen, keys) {\n    super(`Invalid showWhen value: ${showWhen}. Valid values are: ${keys.join(', ')}`);\n  }\n\n}\n\nclass ErrorsConfiguration {\n  constructor() {\n    this.showErrorsWhenInput = 'touched';\n    this.showMaxErrors = undefined;\n  }\n\n}\n\nErrorsConfiguration.ɵfac = function ErrorsConfiguration_Factory(t) {\n  return new (t || ErrorsConfiguration)();\n};\n\nErrorsConfiguration.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ErrorsConfiguration,\n  factory: ErrorsConfiguration.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ErrorsConfiguration, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass OverriddenShowWhen {\n  constructor() {\n    this.controlOverridden$ = new Subject();\n    this.controls = new Map();\n  }\n\n  get(control) {\n    return this.controls.get(control);\n  }\n\n  add(control) {\n    this.controls.set(control, []);\n    this.controlOverridden$.next(control);\n  }\n\n  errorVisibilityChanged(control, errorName, showWhen, isVisible) {\n    const errorsShown = this.controls.get(control);\n\n    if (!errorsShown) {\n      return;\n    }\n\n    const key = `${errorName}-${showWhen}`;\n\n    if (isVisible && !errorsShown.includes(key)) {\n      const newErrorNamesShown = [...errorsShown, key];\n      this.controls.set(control, newErrorNamesShown);\n    }\n\n    if (!isVisible && errorsShown.includes(key)) {\n      const newErrorNamesShown = errorsShown.filter(name => name !== key);\n      this.controls.set(control, newErrorNamesShown);\n    }\n\n    this.controlOverridden$.next(control);\n  }\n\n}\n\nOverriddenShowWhen.ɵfac = function OverriddenShowWhen_Factory(t) {\n  return new (t || OverriddenShowWhen)();\n};\n\nOverriddenShowWhen.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: OverriddenShowWhen,\n  factory: OverriddenShowWhen.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OverriddenShowWhen, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\nclass NgxErrorsFormDirective {\n  constructor(ngForm, formGroupDirective) {\n    this.ngForm = ngForm;\n    this.formGroupDirective = formGroupDirective;\n  }\n\n  get form() {\n    var _a;\n\n    return (_a = this.ngForm) !== null && _a !== void 0 ? _a : this.formGroupDirective;\n  }\n\n}\n\nNgxErrorsFormDirective.ɵfac = function NgxErrorsFormDirective_Factory(t) {\n  return new (t || NgxErrorsFormDirective)(i0.ɵɵdirectiveInject(i1.NgForm, 10), i0.ɵɵdirectiveInject(i1.FormGroupDirective, 10));\n};\n\nNgxErrorsFormDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: NgxErrorsFormDirective,\n  selectors: [[\"form\"]],\n  exportAs: [\"ngxErrorsForm\"]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxErrorsFormDirective, [{\n    type: Directive,\n    args: [{\n      selector: 'form',\n      exportAs: 'ngxErrorsForm'\n    }]\n  }], function () {\n    return [{\n      type: i1.NgForm,\n      decorators: [{\n        type: Self\n      }, {\n        type: Optional\n      }]\n    }, {\n      type: i1.FormGroupDirective,\n      decorators: [{\n        type: Self\n      }, {\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n/**\r\n * Directive to hook into the errors of a given control.\r\n *\r\n * Example:\r\n *\r\n * ```ts\r\n * \\@Component({\r\n *   template: `\r\n *   <div [ngxErrors]=\"myControl\">\r\n *     <div ngxError=\"required\">This input is required</div>\r\n *   </div>\r\n *   `\r\n * })\r\n * export class MyComponent {\r\n *   myControl = new FormControl('', Validators.required)\r\n * }\r\n * ```\r\n * In case the `ngxErrors` directive is a child of a [formGroup], you can specify\r\n * the control by the control name similarly how you'd do it with formControlName:\r\n *\r\n * ```ts\r\n * \\@Component({\r\n *   template: `\r\n *   <form [formGroup]=\"form\">\r\n *     <div ngxErrors=\"firstName\">\r\n *       <div ngxError=\"required\">This input is required</div>\r\n *     </div>\r\n *   </form>\r\n *   `\r\n * })\r\n * export class MyComponent {\r\n *   form = this.fb.group({\r\n *     firstName: ['', Validators.required]\r\n *   });\r\n *   constructor(private fb: FormBuilder) {}\r\n * }\r\n * ```\r\n */\n\n\nclass ErrorsDirective {\n  constructor(formDirective, parentFormGroupDirective, parentFormGroupName, config) {\n    this.formDirective = formDirective;\n    this.parentFormGroupDirective = parentFormGroupDirective;\n    this.parentFormGroupName = parentFormGroupName;\n    this.config = config;\n    this.control$$ = new BehaviorSubject(undefined);\n    this.control$ = this.control$$.asObservable().pipe(filterOutNullish());\n    this.errorsCouldBeHidden$$ = new BehaviorSubject({});\n    this.errorsVisibility$ = this.errorsCouldBeHidden$$.asObservable().pipe(map(errorsCouldBeHidden => {\n      const arr = [];\n      let visibleCount = 0;\n\n      for (const key in errorsCouldBeHidden) {\n        if (errorsCouldBeHidden.hasOwnProperty(key)) {\n          const errorCouldBeHidden = errorsCouldBeHidden[key];\n\n          if (!errorCouldBeHidden) {\n            visibleCount++;\n          }\n\n          const visible = !errorCouldBeHidden && (!this.config.showMaxErrors || visibleCount <= this.config.showMaxErrors);\n          arr.push({\n            key,\n            hidden: !visible\n          });\n        }\n      }\n\n      return arr;\n    }), shareReplay(1));\n  }\n\n  ngAfterViewInit() {\n    this.initAndValidateDirective();\n  }\n\n  visibilityForKey$(key) {\n    return this.errorsVisibility$.pipe(map(errors => errors.find(error => error.key === key)), filterOutNullish(), map(error => error.hidden), distinctUntilChanged());\n  }\n\n  visibilityChanged(errorName, showWhen, hidden) {\n    const key = `${errorName}-${showWhen}`;\n    const val = this.errorsCouldBeHidden$$.getValue();\n\n    if (val[key] !== hidden) {\n      const newVal = Object.assign(Object.assign({}, val), {\n        [key]: hidden\n      });\n      this.errorsCouldBeHidden$$.next(newVal);\n    }\n  }\n\n  initAndValidateDirective() {\n    if (!this._control) {\n      throw new NoControlError();\n    }\n\n    if (typeof this._control === 'string') {\n      if (!this.parentFormGroupDirective) {\n        throw new ParentFormGroupNotFoundError(this._control);\n      }\n\n      const control = !this.parentFormGroupName ? this.parentFormGroupDirective.form.get(this._control) : this.parentFormGroupName.control.get(this._control);\n\n      if (control == null) {\n        throw new ControlNotFoundError(this._control);\n      }\n\n      this.control$$.next(control);\n      return;\n    }\n\n    if (!this.isAbstractControl(this._control)) {\n      throw new ControlInstanceError();\n    }\n\n    this.control$$.next(this._control);\n  }\n\n  isAbstractControl(control) {\n    return control instanceof FormControl || control instanceof FormArray || control instanceof FormGroup;\n  }\n\n}\n\nErrorsDirective.ɵfac = function ErrorsDirective_Factory(t) {\n  return new (t || ErrorsDirective)(i0.ɵɵdirectiveInject(NgxErrorsFormDirective, 12), i0.ɵɵdirectiveInject(i1.FormGroupDirective, 12), i0.ɵɵdirectiveInject(i1.FormGroupName, 12), i0.ɵɵdirectiveInject(ErrorsConfiguration));\n};\n\nErrorsDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: ErrorsDirective,\n  selectors: [[\"\", \"ngxErrors\", \"\"]],\n  inputs: {\n    _control: [\"ngxErrors\", \"_control\"],\n    showWhen: \"showWhen\"\n  },\n  exportAs: [\"ngxErrors\"]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ErrorsDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxErrors]',\n      exportAs: 'ngxErrors'\n    }]\n  }], function () {\n    return [{\n      type: NgxErrorsFormDirective,\n      decorators: [{\n        type: Optional\n      }, {\n        type: SkipSelf\n      }]\n    }, {\n      type: i1.FormGroupDirective,\n      decorators: [{\n        type: Optional\n      }, {\n        type: SkipSelf\n      }]\n    }, {\n      type: i1.FormGroupName,\n      decorators: [{\n        type: Optional\n      }, {\n        type: SkipSelf\n      }]\n    }, {\n      type: ErrorsConfiguration\n    }];\n  }, {\n    _control: [{\n      type: Input,\n      args: ['ngxErrors']\n    }],\n    showWhen: [{\n      type: Input\n    }]\n  });\n})();\n/**\r\n * Directive to provide a validation error for a specific error name.\r\n * Used as a child of ngxErrors directive.\r\n *\r\n * Example:\r\n * ```html\r\n * <div [ngxErrors]=\"control\">\r\n *   <div ngxError=\"required\">This input is required</div>\r\n * </div>\r\n * ```\r\n */\n\n\nclass ErrorDirective {\n  constructor(config, errorStateMatchers, overriddenShowWhen, cdr, // ErrorsDirective is actually required.\n  // use @Optional so that we can throw a custom error\n  errorsDirective) {\n    this.config = config;\n    this.errorStateMatchers = errorStateMatchers;\n    this.overriddenShowWhen = overriddenShowWhen;\n    this.cdr = cdr;\n    this.errorsDirective = errorsDirective;\n    this.subs = new Subscription();\n    this.hidden = true;\n    this.err = {};\n  }\n\n  ngAfterViewInit() {\n    this.validateDirective();\n    this.watchForEventsTriggeringVisibilityChange();\n  }\n\n  ngOnDestroy() {\n    this.subs.unsubscribe();\n  }\n\n  watchForEventsTriggeringVisibilityChange() {\n    var _a;\n\n    const ngSubmit$ = ((_a = this.errorsDirective.formDirective) === null || _a === void 0 ? void 0 : _a.form) ? this.errorsDirective.formDirective.form.ngSubmit.asObservable() : NEVER;\n    let touchedChanges$;\n    const sub = this.errorsDirective.control$.pipe(tap(control => {\n      this.initConfig(control);\n      this.watchForVisibilityChange(control);\n    }), tap(control => {\n      touchedChanges$ = extractTouchedChanges(control);\n      this.calcShouldDisplay(control);\n    }), switchMap(control => {\n      // https://github.com/angular/angular/issues/41519\n      // control.statusChanges do not emit when there's async validator\n      // ugly workaround:\n      let asyncBugWorkaround$ = NEVER;\n\n      if (control.asyncValidator && control.status === 'PENDING') {\n        asyncBugWorkaround$ = timer(0, 50).pipe(switchMap(() => of(control.status)), filter(x => x !== 'PENDING'), first());\n      }\n\n      return merge(control.valueChanges, control.statusChanges, touchedChanges$, ngSubmit$, asyncBugWorkaround$).pipe(auditTime(0), map(() => control));\n    }), tap(control => {\n      this.calcShouldDisplay(control);\n    })).subscribe();\n    this.subs.add(sub);\n  }\n\n  calcShouldDisplay(control) {\n    var _a, _b;\n\n    const hasError = control.hasError(this.errorName);\n    const form = (_b = (_a = this.errorsDirective.formDirective) === null || _a === void 0 ? void 0 : _a.form) !== null && _b !== void 0 ? _b : null;\n    const errorStateMatcher = this.errorStateMatchers.get(this.showWhen);\n\n    if (!errorStateMatcher) {\n      throw new InvalidShowWhenError(this.showWhen, this.errorStateMatchers.validKeys());\n    }\n\n    const hasErrorState = errorStateMatcher.isErrorState(control, form);\n    const couldBeHidden = !(hasErrorState && hasError);\n    this.errorsDirective.visibilityChanged(this.errorName, this.showWhen, couldBeHidden);\n  }\n\n  watchForVisibilityChange(control) {\n    const key = `${this.errorName}-${this.showWhen}`;\n    const sub = this.errorsDirective.visibilityForKey$(key).pipe(tap(hidden => {\n      this.hidden = hidden;\n      this.overriddenShowWhen.errorVisibilityChanged(control, this.errorName, this.showWhen, !this.hidden);\n      this.err = control.getError(this.errorName) || {};\n      this.cdr.detectChanges();\n    })).subscribe();\n    this.subs.add(sub);\n  }\n\n  initConfig(control) {\n    if (this.showWhen) {\n      this.overriddenShowWhen.add(control);\n      return;\n    }\n\n    if (this.errorsDirective.showWhen) {\n      this.showWhen = this.errorsDirective.showWhen;\n      this.overriddenShowWhen.add(control);\n      return;\n    }\n\n    this.showWhen = this.config.showErrorsWhenInput;\n\n    if (this.showWhen === 'formIsSubmitted' && !this.errorsDirective.parentFormGroupDirective) {\n      this.showWhen = 'touched';\n    }\n  }\n\n  validateDirective() {\n    if (this.errorsDirective == null) {\n      throw new NoParentNgxErrorsError();\n    }\n\n    if (typeof this.errorName !== 'string' || this.errorName.trim() === '') {\n      throw new ValueMustBeStringError();\n    }\n  }\n\n}\n\nErrorDirective.ɵfac = function ErrorDirective_Factory(t) {\n  return new (t || ErrorDirective)(i0.ɵɵdirectiveInject(ErrorsConfiguration), i0.ɵɵdirectiveInject(ErrorStateMatchers), i0.ɵɵdirectiveInject(OverriddenShowWhen), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(ErrorsDirective, 8));\n};\n\nErrorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n  type: ErrorDirective,\n  selectors: [[\"\", \"ngxError\", \"\"]],\n  hostVars: 1,\n  hostBindings: function ErrorDirective_HostBindings(rf, ctx) {\n    if (rf & 2) {\n      i0.ɵɵhostProperty(\"hidden\", ctx.hidden);\n    }\n  },\n  inputs: {\n    errorName: [\"ngxError\", \"errorName\"],\n    showWhen: \"showWhen\"\n  },\n  exportAs: [\"ngxError\"]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ErrorDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[ngxError]',\n      exportAs: 'ngxError'\n    }]\n  }], function () {\n    return [{\n      type: ErrorsConfiguration\n    }, {\n      type: ErrorStateMatchers\n    }, {\n      type: OverriddenShowWhen\n    }, {\n      type: i0.ChangeDetectorRef\n    }, {\n      type: ErrorsDirective,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, {\n    hidden: [{\n      type: HostBinding,\n      args: ['hidden']\n    }],\n    errorName: [{\n      type: Input,\n      args: ['ngxError']\n    }],\n    showWhen: [{\n      type: Input\n    }]\n  });\n})();\n\nconst declarationsAndExports = [ErrorsDirective, ErrorDirective, NgxErrorsFormDirective];\nconst defaultConfig = {\n  showErrorsWhenInput: 'touched',\n  showMaxErrors: undefined\n};\n\nfunction mergeErrorsConfiguration(config) {\n  return Object.assign(Object.assign({}, defaultConfig), config);\n}\n\nconst ERROR_STATE_MATCHER_PROVIDERS = [ErrorStateMatchers, ShowOnTouchedErrorStateMatcher, ShowOnDirtyErrorStateMatcher, ShowOnTouchedAndDirtyErrorStateMatcher, ShowOnSubmittedErrorStateMatcher];\n\nclass NgxErrorsModule {\n  static configure(config) {\n    return {\n      ngModule: NgxErrorsModule,\n      providers: [...ERROR_STATE_MATCHER_PROVIDERS, {\n        provide: ErrorsConfiguration,\n        useValue: mergeErrorsConfiguration(config)\n      }]\n    };\n  }\n\n}\n\nNgxErrorsModule.ɵfac = function NgxErrorsModule_Factory(t) {\n  return new (t || NgxErrorsModule)();\n};\n\nNgxErrorsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxErrorsModule\n});\nNgxErrorsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  providers: [ErrorsConfiguration, ...ERROR_STATE_MATCHER_PROVIDERS]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxErrorsModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [...declarationsAndExports],\n      exports: [...declarationsAndExports],\n      providers: [ErrorsConfiguration, ...ERROR_STATE_MATCHER_PROVIDERS]\n    }]\n  }], null, null);\n})();\n/**\r\n * Makes it easy to trigger validation on the control, that depends on\r\n * a value of a different control\r\n */\n\n\nfunction dependentValidator(opts) {\n  let subscribed = false;\n  return formControl => {\n    const form = formControl.root;\n    const {\n      watchControl,\n      condition,\n      validator\n    } = opts;\n    const controlToWatch = watchControl(form);\n\n    if (!controlToWatch) {\n      if (isDevMode()) {\n        console.warn(`dependentValidator could not find specified watchControl`);\n      }\n\n      return null;\n    }\n\n    if (!subscribed) {\n      subscribed = true;\n      controlToWatch.valueChanges.subscribe(() => {\n        formControl.updateValueAndValidity();\n      });\n    }\n\n    if (condition === undefined || condition(controlToWatch.value)) {\n      const validatorFn = validator(controlToWatch.value);\n      return validatorFn(formControl);\n    }\n\n    return null;\n  };\n}\n/*\r\n * Public API Surface of ngx-errors\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { CUSTOM_ERROR_STATE_MATCHERS, ControlInstanceError, ControlNotFoundError, ERROR_STATE_MATCHER_PROVIDERS, ErrorDirective, ErrorStateMatchers, ErrorsConfiguration, ErrorsDirective, InvalidShowWhenError, NgxError, NgxErrorsFormDirective, NgxErrorsModule, NoControlError, NoParentNgxErrorsError, OverriddenShowWhen, ParentFormGroupNotFoundError, ShowOnDirtyErrorStateMatcher, ShowOnSubmittedErrorStateMatcher, ShowOnTouchedAndDirtyErrorStateMatcher, ShowOnTouchedErrorStateMatcher, ValueMustBeStringError, dependentValidator, extractTouchedChanges, filterOutNullish, markDescendantsAsDirty };","map":{"version":3,"sources":["/Users/oluwatomisintaiwo/Projects/Others/fbn-tms/node_modules/@ngspot/ngx-errors/fesm2015/ngspot-ngx-errors.mjs"],"names":["i0","InjectionToken","Injectable","Optional","Inject","Directive","Self","SkipSelf","Input","HostBinding","NgModule","isDevMode","Subject","pipe","BehaviorSubject","Subscription","NEVER","timer","of","merge","filter","map","shareReplay","distinctUntilChanged","tap","switchMap","first","auditTime","i1","FormGroup","FormArray","FormControl","CUSTOM_ERROR_STATE_MATCHERS","ShowOnTouchedErrorStateMatcher","isErrorState","control","form","invalid","touched","submitted","ɵfac","ɵprov","type","ShowOnDirtyErrorStateMatcher","dirty","ShowOnTouchedAndDirtyErrorStateMatcher","ShowOnSubmittedErrorStateMatcher","ErrorStateMatchers","constructor","showOnTouchedErrorStateMatcher","showOnDirtyErrorStateMatcher","showOnTouchedAndDirtyErrorStateMatcher","showOnSubmittedErrorStateMatcher","customErrorStateMatchers","matchers","Object","assign","get","showWhen","validKeys","keys","undefined","decorators","args","extractTouchedChanges","prevMarkAsTouched","markAsTouched","prevMarkAsUntouched","markAsUntouched","touchedChanges$","nextMarkAsTouched","next","bind","nextMarkAsUntouched","asObservable","markDescendantsAsDirty","options","markAsDirty","controls","controlName","forEach","c","filterOutNullish","x","NgxError","Error","message","NoParentNgxErrorsError","ValueMustBeStringError","NoControlError","ControlInstanceError","ControlNotFoundError","name","ParentFormGroupNotFoundError","InvalidShowWhenError","join","ErrorsConfiguration","showErrorsWhenInput","showMaxErrors","OverriddenShowWhen","controlOverridden$","Map","add","set","errorVisibilityChanged","errorName","isVisible","errorsShown","key","includes","newErrorNamesShown","providedIn","NgxErrorsFormDirective","ngForm","formGroupDirective","_a","NgForm","FormGroupDirective","ɵdir","selector","exportAs","ErrorsDirective","formDirective","parentFormGroupDirective","parentFormGroupName","config","control$$","control$","errorsCouldBeHidden$$","errorsVisibility$","errorsCouldBeHidden","arr","visibleCount","hasOwnProperty","errorCouldBeHidden","visible","push","hidden","ngAfterViewInit","initAndValidateDirective","visibilityForKey$","errors","find","error","visibilityChanged","val","getValue","newVal","_control","isAbstractControl","FormGroupName","ErrorDirective","errorStateMatchers","overriddenShowWhen","cdr","errorsDirective","subs","err","validateDirective","watchForEventsTriggeringVisibilityChange","ngOnDestroy","unsubscribe","ngSubmit$","ngSubmit","sub","initConfig","watchForVisibilityChange","calcShouldDisplay","asyncBugWorkaround$","asyncValidator","status","valueChanges","statusChanges","subscribe","_b","hasError","errorStateMatcher","hasErrorState","couldBeHidden","getError","detectChanges","trim","ChangeDetectorRef","declarationsAndExports","defaultConfig","mergeErrorsConfiguration","ERROR_STATE_MATCHER_PROVIDERS","NgxErrorsModule","configure","ngModule","providers","provide","useValue","ɵmod","ɵinj","declarations","exports","dependentValidator","opts","subscribed","formControl","root","watchControl","condition","validator","controlToWatch","console","warn","updateValueAndValidity","value","validatorFn"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, Directive, Self, SkipSelf, Input, HostBinding, NgModule, isDevMode } from '@angular/core';\nimport { Subject, pipe, BehaviorSubject, Subscription, NEVER, timer, of, merge } from 'rxjs';\nimport { filter, map, shareReplay, distinctUntilChanged, tap, switchMap, first, auditTime } from 'rxjs/operators';\nimport * as i1 from '@angular/forms';\nimport { FormGroup, FormArray, FormControl } from '@angular/forms';\n\n/**\r\n * Provides a way to add to available options for when to display an error for\r\n * an invalid control. Options that come by default are\r\n * `'touched'`, `'dirty'`, `'touchedAndDirty'`, `'formIsSubmitted'`.\r\n */\r\nconst CUSTOM_ERROR_STATE_MATCHERS = new InjectionToken('CUSTOM_ERROR_STATE_MATCHERS');\n\nclass ShowOnTouchedErrorStateMatcher {\r\n    isErrorState(control, form) {\r\n        return !!(control &&\r\n            control.invalid &&\r\n            (control.touched || (form && form.submitted)));\r\n    }\r\n}\r\nShowOnTouchedErrorStateMatcher.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ShowOnTouchedErrorStateMatcher, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nShowOnTouchedErrorStateMatcher.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ShowOnTouchedErrorStateMatcher });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ShowOnTouchedErrorStateMatcher, decorators: [{\r\n            type: Injectable\r\n        }] });\r\nclass ShowOnDirtyErrorStateMatcher {\r\n    isErrorState(control, form) {\r\n        return !!(control &&\r\n            control.invalid &&\r\n            (control.dirty || (form && form.submitted)));\r\n    }\r\n}\r\nShowOnDirtyErrorStateMatcher.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ShowOnDirtyErrorStateMatcher, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nShowOnDirtyErrorStateMatcher.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ShowOnDirtyErrorStateMatcher });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ShowOnDirtyErrorStateMatcher, decorators: [{\r\n            type: Injectable\r\n        }] });\r\nclass ShowOnTouchedAndDirtyErrorStateMatcher {\r\n    isErrorState(control, form) {\r\n        return !!(control &&\r\n            control.invalid &&\r\n            ((control.dirty && control.touched) || (form && form.submitted)));\r\n    }\r\n}\r\nShowOnTouchedAndDirtyErrorStateMatcher.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ShowOnTouchedAndDirtyErrorStateMatcher, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nShowOnTouchedAndDirtyErrorStateMatcher.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ShowOnTouchedAndDirtyErrorStateMatcher });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ShowOnTouchedAndDirtyErrorStateMatcher, decorators: [{\r\n            type: Injectable\r\n        }] });\r\nclass ShowOnSubmittedErrorStateMatcher {\r\n    isErrorState(control, form) {\r\n        return !!(control && control.invalid && form && form.submitted);\r\n    }\r\n}\r\nShowOnSubmittedErrorStateMatcher.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ShowOnSubmittedErrorStateMatcher, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nShowOnSubmittedErrorStateMatcher.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ShowOnSubmittedErrorStateMatcher });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ShowOnSubmittedErrorStateMatcher, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nclass ErrorStateMatchers {\r\n    constructor(showOnTouchedErrorStateMatcher, showOnDirtyErrorStateMatcher, showOnTouchedAndDirtyErrorStateMatcher, showOnSubmittedErrorStateMatcher, customErrorStateMatchers) {\r\n        this.matchers = {};\r\n        this.matchers['touched'] = showOnTouchedErrorStateMatcher;\r\n        this.matchers['dirty'] = showOnDirtyErrorStateMatcher;\r\n        this.matchers['touchedAndDirty'] = showOnTouchedAndDirtyErrorStateMatcher;\r\n        this.matchers['formIsSubmitted'] = showOnSubmittedErrorStateMatcher;\r\n        if (customErrorStateMatchers) {\r\n            this.matchers = Object.assign(Object.assign({}, this.matchers), customErrorStateMatchers);\r\n        }\r\n    }\r\n    get(showWhen) {\r\n        return this.matchers[showWhen];\r\n    }\r\n    validKeys() {\r\n        return Object.keys(this.matchers);\r\n    }\r\n}\r\nErrorStateMatchers.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ErrorStateMatchers, deps: [{ token: ShowOnTouchedErrorStateMatcher }, { token: ShowOnDirtyErrorStateMatcher }, { token: ShowOnTouchedAndDirtyErrorStateMatcher }, { token: ShowOnSubmittedErrorStateMatcher }, { token: CUSTOM_ERROR_STATE_MATCHERS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\r\nErrorStateMatchers.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ErrorStateMatchers });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ErrorStateMatchers, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: ShowOnTouchedErrorStateMatcher }, { type: ShowOnDirtyErrorStateMatcher }, { type: ShowOnTouchedAndDirtyErrorStateMatcher }, { type: ShowOnSubmittedErrorStateMatcher }, { type: undefined, decorators: [{\r\n                        type: Optional\r\n                    }, {\r\n                        type: Inject,\r\n                        args: [CUSTOM_ERROR_STATE_MATCHERS]\r\n                    }] }];\r\n    } });\n\n/**\r\n * Extract a touched changed observable from an abstract control\r\n * @param control AbstractControl like object with markAsTouched method\r\n *\r\n * @usage\r\n * ```\r\n * const formControl = new FormControl();\r\n * const touchedChanged$ = extractTouchedChanges(formControl);\r\n * ```\r\n */\r\nconst extractTouchedChanges = (control) => {\r\n    const prevMarkAsTouched = control.markAsTouched;\r\n    const prevMarkAsUntouched = control.markAsUntouched;\r\n    const touchedChanges$ = new Subject();\r\n    function nextMarkAsTouched(...args) {\r\n        touchedChanges$.next(true);\r\n        prevMarkAsTouched.bind(control)(...args);\r\n    }\r\n    function nextMarkAsUntouched(...args) {\r\n        touchedChanges$.next(false);\r\n        prevMarkAsUntouched.bind(control)(...args);\r\n    }\r\n    control.markAsTouched = nextMarkAsTouched;\r\n    control.markAsUntouched = nextMarkAsUntouched;\r\n    return touchedChanges$.asObservable();\r\n};\r\n/**\r\n * Marks the provided control as well as all of its children as dirty\r\n * @param options to be passed into control.markAsDirty() call\r\n */\r\nfunction markDescendantsAsDirty(control, options) {\r\n    control.markAsDirty(options);\r\n    if (control instanceof FormGroup || control instanceof FormArray) {\r\n        const controls = Object.keys(control.controls).map((controlName) => control.get(controlName));\r\n        controls.forEach((c) => {\r\n            c.markAsDirty(options);\r\n            if (c.controls) {\r\n                markDescendantsAsDirty(c, options);\r\n            }\r\n        });\r\n    }\r\n}\r\nfunction filterOutNullish() {\r\n    return pipe(filter((x) => x != null));\r\n}\n\nclass NgxError extends Error {\r\n    constructor(message) {\r\n        super(`NgxError: ${message}`);\r\n    }\r\n}\r\nclass NoParentNgxErrorsError extends NgxError {\r\n    constructor() {\r\n        super('Directive ngxError requires a parent directive ngxErrors');\r\n    }\r\n}\r\nclass ValueMustBeStringError extends NgxError {\r\n    constructor() {\r\n        super('Directive ngxError requires a string value');\r\n    }\r\n}\r\nclass NoControlError extends NgxError {\r\n    constructor() {\r\n        super('Directive ngxErrors requires either control name or control instance');\r\n    }\r\n}\r\nclass ControlInstanceError extends NgxError {\r\n    constructor() {\r\n        super('Control must be either a FormGroup, FormControl or FormArray');\r\n    }\r\n}\r\nclass ControlNotFoundError extends NgxError {\r\n    constructor(name) {\r\n        super(`Control \"${name}\" could not be found`);\r\n    }\r\n}\r\nclass ParentFormGroupNotFoundError extends NgxError {\r\n    constructor(name) {\r\n        super(`Can't search for control \"${name}\" because parent FormGroup is not found`);\r\n    }\r\n}\r\nclass InvalidShowWhenError extends NgxError {\r\n    constructor(showWhen, keys) {\r\n        super(`Invalid showWhen value: ${showWhen}. Valid values are: ${keys.join(', ')}`);\r\n    }\r\n}\n\nclass ErrorsConfiguration {\r\n    constructor() {\r\n        this.showErrorsWhenInput = 'touched';\r\n        this.showMaxErrors = undefined;\r\n    }\r\n}\r\nErrorsConfiguration.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ErrorsConfiguration, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nErrorsConfiguration.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ErrorsConfiguration });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ErrorsConfiguration, decorators: [{\r\n            type: Injectable\r\n        }] });\n\nclass OverriddenShowWhen {\r\n    constructor() {\r\n        this.controlOverridden$ = new Subject();\r\n        this.controls = new Map();\r\n    }\r\n    get(control) {\r\n        return this.controls.get(control);\r\n    }\r\n    add(control) {\r\n        this.controls.set(control, []);\r\n        this.controlOverridden$.next(control);\r\n    }\r\n    errorVisibilityChanged(control, errorName, showWhen, isVisible) {\r\n        const errorsShown = this.controls.get(control);\r\n        if (!errorsShown) {\r\n            return;\r\n        }\r\n        const key = `${errorName}-${showWhen}`;\r\n        if (isVisible && !errorsShown.includes(key)) {\r\n            const newErrorNamesShown = [...errorsShown, key];\r\n            this.controls.set(control, newErrorNamesShown);\r\n        }\r\n        if (!isVisible && errorsShown.includes(key)) {\r\n            const newErrorNamesShown = errorsShown.filter((name) => name !== key);\r\n            this.controls.set(control, newErrorNamesShown);\r\n        }\r\n        this.controlOverridden$.next(control);\r\n    }\r\n}\r\nOverriddenShowWhen.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: OverriddenShowWhen, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\nOverriddenShowWhen.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: OverriddenShowWhen, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: OverriddenShowWhen, decorators: [{\r\n            type: Injectable,\r\n            args: [{ providedIn: 'root' }]\r\n        }] });\n\nclass NgxErrorsFormDirective {\r\n    constructor(ngForm, formGroupDirective) {\r\n        this.ngForm = ngForm;\r\n        this.formGroupDirective = formGroupDirective;\r\n    }\r\n    get form() {\r\n        var _a;\r\n        return (_a = this.ngForm) !== null && _a !== void 0 ? _a : this.formGroupDirective;\r\n    }\r\n}\r\nNgxErrorsFormDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: NgxErrorsFormDirective, deps: [{ token: i1.NgForm, optional: true, self: true }, { token: i1.FormGroupDirective, optional: true, self: true }], target: i0.ɵɵFactoryTarget.Directive });\r\nNgxErrorsFormDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.1.0\", type: NgxErrorsFormDirective, selector: \"form\", exportAs: [\"ngxErrorsForm\"], ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: NgxErrorsFormDirective, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: 'form',\r\n                    exportAs: 'ngxErrorsForm',\r\n                }]\r\n        }], ctorParameters: function () {\r\n        return [{ type: i1.NgForm, decorators: [{\r\n                        type: Self\r\n                    }, {\r\n                        type: Optional\r\n                    }] }, { type: i1.FormGroupDirective, decorators: [{\r\n                        type: Self\r\n                    }, {\r\n                        type: Optional\r\n                    }] }];\r\n    } });\n\n/**\r\n * Directive to hook into the errors of a given control.\r\n *\r\n * Example:\r\n *\r\n * ```ts\r\n * \\@Component({\r\n *   template: `\r\n *   <div [ngxErrors]=\"myControl\">\r\n *     <div ngxError=\"required\">This input is required</div>\r\n *   </div>\r\n *   `\r\n * })\r\n * export class MyComponent {\r\n *   myControl = new FormControl('', Validators.required)\r\n * }\r\n * ```\r\n * In case the `ngxErrors` directive is a child of a [formGroup], you can specify\r\n * the control by the control name similarly how you'd do it with formControlName:\r\n *\r\n * ```ts\r\n * \\@Component({\r\n *   template: `\r\n *   <form [formGroup]=\"form\">\r\n *     <div ngxErrors=\"firstName\">\r\n *       <div ngxError=\"required\">This input is required</div>\r\n *     </div>\r\n *   </form>\r\n *   `\r\n * })\r\n * export class MyComponent {\r\n *   form = this.fb.group({\r\n *     firstName: ['', Validators.required]\r\n *   });\r\n *   constructor(private fb: FormBuilder) {}\r\n * }\r\n * ```\r\n */\r\nclass ErrorsDirective {\r\n    constructor(formDirective, parentFormGroupDirective, parentFormGroupName, config) {\r\n        this.formDirective = formDirective;\r\n        this.parentFormGroupDirective = parentFormGroupDirective;\r\n        this.parentFormGroupName = parentFormGroupName;\r\n        this.config = config;\r\n        this.control$$ = new BehaviorSubject(undefined);\r\n        this.control$ = this.control$$.asObservable().pipe(filterOutNullish());\r\n        this.errorsCouldBeHidden$$ = new BehaviorSubject({});\r\n        this.errorsVisibility$ = this.errorsCouldBeHidden$$.asObservable().pipe(map((errorsCouldBeHidden) => {\r\n            const arr = [];\r\n            let visibleCount = 0;\r\n            for (const key in errorsCouldBeHidden) {\r\n                if (errorsCouldBeHidden.hasOwnProperty(key)) {\r\n                    const errorCouldBeHidden = errorsCouldBeHidden[key];\r\n                    if (!errorCouldBeHidden) {\r\n                        visibleCount++;\r\n                    }\r\n                    const visible = !errorCouldBeHidden &&\r\n                        (!this.config.showMaxErrors ||\r\n                            visibleCount <= this.config.showMaxErrors);\r\n                    arr.push({ key, hidden: !visible });\r\n                }\r\n            }\r\n            return arr;\r\n        }), shareReplay(1));\r\n    }\r\n    ngAfterViewInit() {\r\n        this.initAndValidateDirective();\r\n    }\r\n    visibilityForKey$(key) {\r\n        return this.errorsVisibility$.pipe(map((errors) => errors.find((error) => error.key === key)), filterOutNullish(), map((error) => error.hidden), distinctUntilChanged());\r\n    }\r\n    visibilityChanged(errorName, showWhen, hidden) {\r\n        const key = `${errorName}-${showWhen}`;\r\n        const val = this.errorsCouldBeHidden$$.getValue();\r\n        if (val[key] !== hidden) {\r\n            const newVal = Object.assign(Object.assign({}, val), { [key]: hidden });\r\n            this.errorsCouldBeHidden$$.next(newVal);\r\n        }\r\n    }\r\n    initAndValidateDirective() {\r\n        if (!this._control) {\r\n            throw new NoControlError();\r\n        }\r\n        if (typeof this._control === 'string') {\r\n            if (!this.parentFormGroupDirective) {\r\n                throw new ParentFormGroupNotFoundError(this._control);\r\n            }\r\n            const control = !this.parentFormGroupName\r\n                ? this.parentFormGroupDirective.form.get(this._control)\r\n                : this.parentFormGroupName.control.get(this._control);\r\n            if (control == null) {\r\n                throw new ControlNotFoundError(this._control);\r\n            }\r\n            this.control$$.next(control);\r\n            return;\r\n        }\r\n        if (!this.isAbstractControl(this._control)) {\r\n            throw new ControlInstanceError();\r\n        }\r\n        this.control$$.next(this._control);\r\n    }\r\n    isAbstractControl(control) {\r\n        return (control instanceof FormControl ||\r\n            control instanceof FormArray ||\r\n            control instanceof FormGroup);\r\n    }\r\n}\r\nErrorsDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ErrorsDirective, deps: [{ token: NgxErrorsFormDirective, optional: true, skipSelf: true }, { token: i1.FormGroupDirective, optional: true, skipSelf: true }, { token: i1.FormGroupName, optional: true, skipSelf: true }, { token: ErrorsConfiguration }], target: i0.ɵɵFactoryTarget.Directive });\r\nErrorsDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.1.0\", type: ErrorsDirective, selector: \"[ngxErrors]\", inputs: { _control: [\"ngxErrors\", \"_control\"], showWhen: \"showWhen\" }, exportAs: [\"ngxErrors\"], ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ErrorsDirective, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[ngxErrors]',\r\n                    exportAs: 'ngxErrors',\r\n                }]\r\n        }], ctorParameters: function () {\r\n        return [{ type: NgxErrorsFormDirective, decorators: [{\r\n                        type: Optional\r\n                    }, {\r\n                        type: SkipSelf\r\n                    }] }, { type: i1.FormGroupDirective, decorators: [{\r\n                        type: Optional\r\n                    }, {\r\n                        type: SkipSelf\r\n                    }] }, { type: i1.FormGroupName, decorators: [{\r\n                        type: Optional\r\n                    }, {\r\n                        type: SkipSelf\r\n                    }] }, { type: ErrorsConfiguration }];\r\n    }, propDecorators: { _control: [{\r\n                type: Input,\r\n                args: ['ngxErrors']\r\n            }], showWhen: [{\r\n                type: Input\r\n            }] } });\n\n/**\r\n * Directive to provide a validation error for a specific error name.\r\n * Used as a child of ngxErrors directive.\r\n *\r\n * Example:\r\n * ```html\r\n * <div [ngxErrors]=\"control\">\r\n *   <div ngxError=\"required\">This input is required</div>\r\n * </div>\r\n * ```\r\n */\r\nclass ErrorDirective {\r\n    constructor(config, errorStateMatchers, overriddenShowWhen, cdr, \r\n    // ErrorsDirective is actually required.\r\n    // use @Optional so that we can throw a custom error\r\n    errorsDirective) {\r\n        this.config = config;\r\n        this.errorStateMatchers = errorStateMatchers;\r\n        this.overriddenShowWhen = overriddenShowWhen;\r\n        this.cdr = cdr;\r\n        this.errorsDirective = errorsDirective;\r\n        this.subs = new Subscription();\r\n        this.hidden = true;\r\n        this.err = {};\r\n    }\r\n    ngAfterViewInit() {\r\n        this.validateDirective();\r\n        this.watchForEventsTriggeringVisibilityChange();\r\n    }\r\n    ngOnDestroy() {\r\n        this.subs.unsubscribe();\r\n    }\r\n    watchForEventsTriggeringVisibilityChange() {\r\n        var _a;\r\n        const ngSubmit$ = ((_a = this.errorsDirective.formDirective) === null || _a === void 0 ? void 0 : _a.form)\r\n            ? this.errorsDirective.formDirective.form.ngSubmit.asObservable()\r\n            : NEVER;\r\n        let touchedChanges$;\r\n        const sub = this.errorsDirective.control$\r\n            .pipe(tap((control) => {\r\n            this.initConfig(control);\r\n            this.watchForVisibilityChange(control);\r\n        }), tap((control) => {\r\n            touchedChanges$ = extractTouchedChanges(control);\r\n            this.calcShouldDisplay(control);\r\n        }), switchMap((control) => {\r\n            // https://github.com/angular/angular/issues/41519\r\n            // control.statusChanges do not emit when there's async validator\r\n            // ugly workaround:\r\n            let asyncBugWorkaround$ = NEVER;\r\n            if (control.asyncValidator && control.status === 'PENDING') {\r\n                asyncBugWorkaround$ = timer(0, 50).pipe(switchMap(() => of(control.status)), filter((x) => x !== 'PENDING'), first());\r\n            }\r\n            return merge(control.valueChanges, control.statusChanges, touchedChanges$, ngSubmit$, asyncBugWorkaround$).pipe(auditTime(0), map(() => control));\r\n        }), tap((control) => {\r\n            this.calcShouldDisplay(control);\r\n        }))\r\n            .subscribe();\r\n        this.subs.add(sub);\r\n    }\r\n    calcShouldDisplay(control) {\r\n        var _a, _b;\r\n        const hasError = control.hasError(this.errorName);\r\n        const form = (_b = (_a = this.errorsDirective.formDirective) === null || _a === void 0 ? void 0 : _a.form) !== null && _b !== void 0 ? _b : null;\r\n        const errorStateMatcher = this.errorStateMatchers.get(this.showWhen);\r\n        if (!errorStateMatcher) {\r\n            throw new InvalidShowWhenError(this.showWhen, this.errorStateMatchers.validKeys());\r\n        }\r\n        const hasErrorState = errorStateMatcher.isErrorState(control, form);\r\n        const couldBeHidden = !(hasErrorState && hasError);\r\n        this.errorsDirective.visibilityChanged(this.errorName, this.showWhen, couldBeHidden);\r\n    }\r\n    watchForVisibilityChange(control) {\r\n        const key = `${this.errorName}-${this.showWhen}`;\r\n        const sub = this.errorsDirective\r\n            .visibilityForKey$(key)\r\n            .pipe(tap((hidden) => {\r\n            this.hidden = hidden;\r\n            this.overriddenShowWhen.errorVisibilityChanged(control, this.errorName, this.showWhen, !this.hidden);\r\n            this.err = control.getError(this.errorName) || {};\r\n            this.cdr.detectChanges();\r\n        }))\r\n            .subscribe();\r\n        this.subs.add(sub);\r\n    }\r\n    initConfig(control) {\r\n        if (this.showWhen) {\r\n            this.overriddenShowWhen.add(control);\r\n            return;\r\n        }\r\n        if (this.errorsDirective.showWhen) {\r\n            this.showWhen = this.errorsDirective.showWhen;\r\n            this.overriddenShowWhen.add(control);\r\n            return;\r\n        }\r\n        this.showWhen = this.config.showErrorsWhenInput;\r\n        if (this.showWhen === 'formIsSubmitted' &&\r\n            !this.errorsDirective.parentFormGroupDirective) {\r\n            this.showWhen = 'touched';\r\n        }\r\n    }\r\n    validateDirective() {\r\n        if (this.errorsDirective == null) {\r\n            throw new NoParentNgxErrorsError();\r\n        }\r\n        if (typeof this.errorName !== 'string' || this.errorName.trim() === '') {\r\n            throw new ValueMustBeStringError();\r\n        }\r\n    }\r\n}\r\nErrorDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ErrorDirective, deps: [{ token: ErrorsConfiguration }, { token: ErrorStateMatchers }, { token: OverriddenShowWhen }, { token: i0.ChangeDetectorRef }, { token: ErrorsDirective, optional: true }], target: i0.ɵɵFactoryTarget.Directive });\r\nErrorDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: \"12.0.0\", version: \"13.1.0\", type: ErrorDirective, selector: \"[ngxError]\", inputs: { errorName: [\"ngxError\", \"errorName\"], showWhen: \"showWhen\" }, host: { properties: { \"hidden\": \"this.hidden\" } }, exportAs: [\"ngxError\"], ngImport: i0 });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ErrorDirective, decorators: [{\r\n            type: Directive,\r\n            args: [{\r\n                    selector: '[ngxError]',\r\n                    exportAs: 'ngxError',\r\n                }]\r\n        }], ctorParameters: function () {\r\n        return [{ type: ErrorsConfiguration }, { type: ErrorStateMatchers }, { type: OverriddenShowWhen }, { type: i0.ChangeDetectorRef }, { type: ErrorsDirective, decorators: [{\r\n                        type: Optional\r\n                    }] }];\r\n    }, propDecorators: { hidden: [{\r\n                type: HostBinding,\r\n                args: ['hidden']\r\n            }], errorName: [{\r\n                type: Input,\r\n                args: ['ngxError']\r\n            }], showWhen: [{\r\n                type: Input\r\n            }] } });\n\nconst declarationsAndExports = [\r\n    ErrorsDirective,\r\n    ErrorDirective,\r\n    NgxErrorsFormDirective,\r\n];\r\nconst defaultConfig = {\r\n    showErrorsWhenInput: 'touched',\r\n    showMaxErrors: undefined,\r\n};\r\nfunction mergeErrorsConfiguration(config) {\r\n    return Object.assign(Object.assign({}, defaultConfig), config);\r\n}\r\nconst ERROR_STATE_MATCHER_PROVIDERS = [\r\n    ErrorStateMatchers,\r\n    ShowOnTouchedErrorStateMatcher,\r\n    ShowOnDirtyErrorStateMatcher,\r\n    ShowOnTouchedAndDirtyErrorStateMatcher,\r\n    ShowOnSubmittedErrorStateMatcher,\r\n];\r\nclass NgxErrorsModule {\r\n    static configure(config) {\r\n        return {\r\n            ngModule: NgxErrorsModule,\r\n            providers: [\r\n                ...ERROR_STATE_MATCHER_PROVIDERS,\r\n                {\r\n                    provide: ErrorsConfiguration,\r\n                    useValue: mergeErrorsConfiguration(config),\r\n                },\r\n            ],\r\n        };\r\n    }\r\n}\r\nNgxErrorsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: NgxErrorsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\nNgxErrorsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: NgxErrorsModule, declarations: [ErrorsDirective,\r\n        ErrorDirective,\r\n        NgxErrorsFormDirective], exports: [ErrorsDirective,\r\n        ErrorDirective,\r\n        NgxErrorsFormDirective] });\r\nNgxErrorsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: NgxErrorsModule, providers: [ErrorsConfiguration, ...ERROR_STATE_MATCHER_PROVIDERS] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: NgxErrorsModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    declarations: [...declarationsAndExports],\r\n                    exports: [...declarationsAndExports],\r\n                    providers: [ErrorsConfiguration, ...ERROR_STATE_MATCHER_PROVIDERS],\r\n                }]\r\n        }] });\n\n/**\r\n * Makes it easy to trigger validation on the control, that depends on\r\n * a value of a different control\r\n */\r\nfunction dependentValidator(opts) {\r\n    let subscribed = false;\r\n    return (formControl) => {\r\n        const form = formControl.root;\r\n        const { watchControl, condition, validator } = opts;\r\n        const controlToWatch = watchControl(form);\r\n        if (!controlToWatch) {\r\n            if (isDevMode()) {\r\n                console.warn(`dependentValidator could not find specified watchControl`);\r\n            }\r\n            return null;\r\n        }\r\n        if (!subscribed) {\r\n            subscribed = true;\r\n            controlToWatch.valueChanges.subscribe(() => {\r\n                formControl.updateValueAndValidity();\r\n            });\r\n        }\r\n        if (condition === undefined || condition(controlToWatch.value)) {\r\n            const validatorFn = validator(controlToWatch.value);\r\n            return validatorFn(formControl);\r\n        }\r\n        return null;\r\n    };\r\n}\n\n/*\r\n * Public API Surface of ngx-errors\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { CUSTOM_ERROR_STATE_MATCHERS, ControlInstanceError, ControlNotFoundError, ERROR_STATE_MATCHER_PROVIDERS, ErrorDirective, ErrorStateMatchers, ErrorsConfiguration, ErrorsDirective, InvalidShowWhenError, NgxError, NgxErrorsFormDirective, NgxErrorsModule, NoControlError, NoParentNgxErrorsError, OverriddenShowWhen, ParentFormGroupNotFoundError, ShowOnDirtyErrorStateMatcher, ShowOnSubmittedErrorStateMatcher, ShowOnTouchedAndDirtyErrorStateMatcher, ShowOnTouchedErrorStateMatcher, ValueMustBeStringError, dependentValidator, extractTouchedChanges, filterOutNullish, markDescendantsAsDirty };\n"]},"metadata":{},"sourceType":"module"}